<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <script src="https://unpkg.com/ipfs/dist/index.min.js"></script>
</head>
<script>
    const IPFS = {
        create() {
            const node = new Ipfs({
                config: {
                    Bootstrap: [
                        "/dns4/ams-1.bootstrap.libp2p.io/tcp/443/wss/ipfs/QmSoLer265NRgSp2LA3dPaeykiS1J6DifTC88f5uVQKNAd",
                        "/dns4/lon-1.bootstrap.libp2p.io/tcp/443/wss/ipfs/QmSoLMeWqB7YGVLJN3pNLQpmmEk35v6wYtsMGLzSr5QBU3",
                        "/dns4/sfo-3.bootstrap.libp2p.io/tcp/443/wss/ipfs/QmSoLPppuBtQSGwKDZT2M73ULpjvfd3aZ6ha4oFGL1KrGM",
                        "/dns4/sgp-1.bootstrap.libp2p.io/tcp/443/wss/ipfs/QmSoLSafTMBsPKadTEgaXctDQVcqN88CNLHXMkTNwMKPnu",
                        "/dns4/nyc-1.bootstrap.libp2p.io/tcp/443/wss/ipfs/QmSoLueR4xBeUbY9WZ9xGUUxunbKWcrNFTDAadQJmocnWm",
                        "/dns4/nyc-2.bootstrap.libp2p.io/tcp/443/wss/ipfs/QmSoLV4Bbm51jM9C4gDYZQ9Cy3U6aXMJDAbzgu2fzaDs64"
                    ]
                }
            })
            return new Promise((resolve, reject) =>
                node.on("ready", () => resolve(node))
            )
        },
        add(node, text) {
            const file = new node.types.Buffer(text)
            return new Promise((resolve, reject) =>
                node.files.add(file, (error, result) => {
                    if (error) {
                        reject(error)
                    } else {
                        const [{ hash }] = result
                        resolve(hash)
                    }
                })
            )
        },
        cat(node, hash) {
            let result = ""
            return new Promise((resolve, reject) =>
                node.files.cat(hash, (error, stream) => {
                    if (error) {
                        reject(error)
                    } else {
                        stream.on("data", chunk => result += chunk.toString())
                        stream.on("error", error => reject(error))
                        stream.on("end", () => resolve(result))
                    }
                })
            )
        }
    }
</script>
</html>